<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SmoothVoice - Audio Silence Remover</title>
    <style>
        :root {
            --primary-color: #3498db;
            --primary-hover: #2980b9;
            --dark-color: #2c3e50;
            --light-color: #ecf0f1;
            --danger-color: #e74c3c;
            --success-color: #2ecc71;
            --border-radius: 6px;
            --shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f9f9f9;
            color: var(--dark-color);
            line-height: 1.6;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: var(--primary-color);
        }
        
        p {
            color: #666;
            margin-bottom: 20px;
        }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }
        
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
        
        .card {
            background: white;
            border-radius: var(--border-radius);
            padding: 25px;
            box-shadow: var(--shadow);
            margin-bottom: 20px;
        }
        
        .section-title {
            font-size: 1.2rem;
            margin-bottom: 20px;
            color: var(--dark-color);
            display: flex;
            align-items: center;
        }
        
        .section-title svg {
            margin-right: 10px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .file-input-container {
            position: relative;
            margin-bottom: 20px;
        }
        
        .file-input-container label {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 160px;
            border: 2px dashed #ddd;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .file-input-container label:hover {
            border-color: var(--primary-color);
            background-color: rgba(52, 152, 219, 0.05);
        }
        
        .file-input-container svg {
            margin-bottom: 10px;
        }
        
        .file-input-container input[type="file"] {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }
        
        .input-range {
            width: 100%;
            -webkit-appearance: none;
            height: 8px;
            border-radius: 4px;
            background: #ddd;
            outline: none;
            margin-top: 10px;
        }
        
        .input-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
        }
        
        .range-values {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 0.8rem;
            color: #777;
        }
        
        .btn {
            display: inline-block;
            padding: 12px 20px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: all 0.3s;
            width: 100%;
        }
        
        .btn:hover {
            background: var(--primary-hover);
        }
        
        .btn-reset {
            background: transparent;
            border: 1px solid #ddd;
            color: #666;
            margin-top: 10px;
        }
        
        .btn-reset:hover {
            background: #f1f1f1;
        }
        
        .btn-danger {
            background: var(--danger-color);
        }
        
        .btn-danger:hover {
            background: #c0392b;
        }
        
        .audio-players {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }
        
        .audio-player {
            width: 100%;
            margin-bottom: 10px;
        }
        
        .player-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        .progress-container {
            margin-top: 20px;
            display: none;
        }
        
        .progress-bar {
            height: 8px;
            background-color: #ddd;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background-color: var(--primary-color);
            width: 0%;
            transition: width 0.3s;
        }
        
        .status {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 20px;
        }
        
        .file-info {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 20px;
            display: none;
        }

        #downloadSection {
            display: none;
            margin-top: 20px;
        }
        
        .download-btn {
            background-color: var(--success-color);
        }
        
        .download-btn:hover {
            background-color: #27ae60;
        }
        
        .stats {
            margin-top: 20px;
            font-size: 0.9rem;
            display: none;
        }
        
        .stats-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .value {
            font-weight: bold;
        }
        
        .settings-row {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .settings-row label {
            flex: 0 0 180px;
            margin-bottom: 0;
        }
        
        .settings-row .range-container {
            flex: 1;
        }
        
        .range-container {
            position: relative;
        }
        
        .range-value {
            position: absolute;
            right: 0;
            top: -25px;
            background: var(--primary-color);
            color: white;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.8rem;
        }
    </style>
</head>
<body>
    <header>
        <h1>SmoothVoice</h1>
        <p>Remove silence from audio files with smooth crossfade transitions</p>
    </header>
    
    <div class="container">
        <div class="left-column">
            <div class="card">
                <h2 class="section-title">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                    Upload Audio
                </h2>
                <div class="file-input-container">
                    <label for="audioFile">
                        <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="17 8 12 3 7 8"></polyline>
                            <line x1="12" y1="3" x2="12" y2="15"></line>
                        </svg>
                        <span>Drop your WAV file here, or click to browse</span>
                    </label>
                    <input type="file" id="audioFile" accept=".wav" />
                </div>
                
                <div class="file-info" id="fileInfo">
                    <strong>File:</strong> <span id="fileName">No file selected</span><br>
                    <strong>Size:</strong> <span id="fileSize">0 KB</span><br>
                    <strong>Duration:</strong> <span id="fileDuration">0 seconds</span>
                </div>
                
                <div class="audio-players" id="inputAudioContainer" style="display:none;">
                    <div>
                        <span class="player-label">Original Audio:</span>
                        <audio id="inputAudio" controls class="audio-player"></audio>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <h2 class="section-title">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="8" x2="12" y2="16"></line>
                        <line x1="8" y1="12" x2="16" y2="12"></line>
                    </svg>
                    Silence Detection Settings
                </h2>
                
                <div class="settings-row">
                    <label for="minSilenceLen">Minimum Silence Length:</label>
                    <div class="range-container">
                        <span class="range-value" id="minSilenceValue">140 ms</span>
                        <input type="range" id="minSilenceLen" class="input-range" min="50" max="1000" step="10" value="140">
                        <div class="range-values">
                            <span>50ms</span>
                            <span>1000ms</span>
                        </div>
                    </div>
                </div>
                
                <div class="settings-row">
                    <label for="silenceThresh">Silence Threshold:</label>
                    <div class="range-container">
                        <span class="range-value" id="silenceThreshValue">-40 dB</span>
                        <input type="range" id="silenceThresh" class="input-range" min="-60" max="-20" step="1" value="-40">
                        <div class="range-values">
                            <span>-60dB</span>
                            <span>-20dB</span>
                        </div>
                    </div>
                </div>
                
                <div class="settings-row">
                    <label for="keepSilence">Keep Silence:</label>
                    <div class="range-container">
                        <span class="range-value" id="keepSilenceValue">25 ms</span>
                        <input type="range" id="keepSilence" class="input-range" min="0" max="300" step="5" value="25">
                        <div class="range-values">
                            <span>0ms</span>
                            <span>300ms</span>
                        </div>
                    </div>
                </div>
                
                <div class="settings-row">
                    <label for="crossfade">Crossfade Duration:</label>
                    <div class="range-container">
                        <span class="range-value" id="crossfadeValue">15 ms</span>
                        <input type="range" id="crossfade" class="input-range" min="0" max="100" step="1" value="15">
                        <div class="range-values">
                            <span>0ms</span>
                            <span>100ms</span>
                        </div>
                    </div>
                </div>
                
                <button id="resetSettings" class="btn btn-reset">Reset to Defaults</button>
            </div>
        </div>
        
        <div class="right-column">
            <div class="card">
                <h2 class="section-title">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 20h9"></path>
                        <path d="M16.5 3.5a2.12 2.12 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
                    </svg>
                    Process Audio
                </h2>
                
                <p>Process your audio file to remove silence with smooth transitions.</p>
                
                <button id="processBtn" class="btn" disabled>Process Audio</button>
                
                <div class="progress-container" id="progressContainer">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="status" id="statusText">Processing...</div>
                </div>
                
                <div class="stats" id="stats">
                    <div class="stats-item">
                        <span>Original Duration:</span>
                        <span class="value" id="originalDuration">0.00 sec</span>
                    </div>
                    <div class="stats-item">
                        <span>New Duration:</span>
                        <span class="value" id="newDuration">0.00 sec</span>
                    </div>
                    <div class="stats-item">
                        <span>Time Saved:</span>
                        <span class="value" id="timeSaved">0.00 sec (0%)</span>
                    </div>
                </div>
                
                <div id="outputAudioContainer" style="display:none;" class="audio-players">
                    <div>
                        <span class="player-label">Processed Audio:</span>
                        <audio id="outputAudio" controls class="audio-player"></audio>
                    </div>
                </div>
                
                <div id="downloadSection">
                    <button id="downloadBtn" class="btn download-btn">Download Processed Audio</button>
                </div>
            </div>
            
            <div class="card">
                <h2 class="section-title">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                        <line x1="12" y1="17" x2="12.01" y2="17"></line>
                    </svg>
                    How It Works
                </h2>
                <p>This tool processes your audio files to remove silence while maintaining natural sound with smooth crossfades:</p>
                <ol style="padding-left: 20px; margin-bottom: 20px;">
                    <li>Upload a WAV audio file</li>
                    <li>Adjust the settings to fine-tune silence detection</li>
                    <li>Process the audio to remove silence</li>
                    <li>Listen to the result and download if satisfied</li>
                </ol>
                <p><strong>Settings explained:</strong></p>
                <ul style="padding-left: 20px;">
                    <li><strong>Minimum Silence Length:</strong> The minimum duration of silence to detect (in milliseconds)</li>
                    <li><strong>Silence Threshold:</strong> The volume level below which audio is considered silence (in dB)</li>
                    <li><strong>Keep Silence:</strong> How much silence to preserve before/after each non-silent segment</li>
                    <li><strong>Crossfade Duration:</strong> How long the crossfade between segments should be</li>
                </ul>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/wavesurfer.js/2.0.6/wavesurfer.min.js"></script>
    <script>

      document.addEventListener('DOMContentLoaded', function() {
    // DOM Elements
    const audioFileInput = document.getElementById('audioFile');
    const processBtn = document.getElementById('processBtn');
    const resetSettingsBtn = document.getElementById('resetSettings');
    const downloadBtn = document.getElementById('downloadBtn');
    const progressContainer = document.getElementById('progressContainer');
    const progressFill = document.getElementById('progressFill');
    const statusText = document.getElementById('statusText');
    const fileInfoDiv = document.getElementById('fileInfo');
    const fileName = document.getElementById('fileName');
    const fileSize = document.getElementById('fileSize');
    const fileDuration = document.getElementById('fileDuration');
    const stats = document.getElementById('stats');
    const originalDuration = document.getElementById('originalDuration');
    const newDuration = document.getElementById('newDuration');
    const timeSaved = document.getElementById('timeSaved');
    const inputAudioContainer = document.getElementById('inputAudioContainer');
    const outputAudioContainer = document.getElementById('outputAudioContainer');
    const inputAudio = document.getElementById('inputAudio');
    const outputAudio = document.getElementById('outputAudio');
    const downloadSection = document.getElementById('downloadSection');
    
    // Settings sliders
    const minSilenceLenSlider = document.getElementById('minSilenceLen');
    const silenceThreshSlider = document.getElementById('silenceThresh');
    const keepSilenceSlider = document.getElementById('keepSilence');
    const crossfadeSlider = document.getElementById('crossfade');
    
    // Settings value displays
    const minSilenceValue = document.getElementById('minSilenceValue');
    const silenceThreshValue = document.getElementById('silenceThreshValue');
    const keepSilenceValue = document.getElementById('keepSilenceValue');
    const crossfadeValue = document.getElementById('crossfadeValue');
    
    // Variables
    let audioContext;
    let audioBuffer;
    let originalAudioBuffer;
    let processedAudioBuffer;
    let processedBlob;
    
    // Default settings
    const defaultSettings = {
        minSilenceLen: 140,
        silenceThresh: -40,
        keepSilence: 25,
        crossfade: 15
    };
    
    // Load settings from localStorage or use defaults
    function loadSettings() {
        const savedSettings = JSON.parse(localStorage.getItem('audioProcessorSettings')) || {};
        
        minSilenceLenSlider.value = savedSettings.minSilenceLen || defaultSettings.minSilenceLen;
        silenceThreshSlider.value = savedSettings.silenceThresh || defaultSettings.silenceThresh;
        keepSilenceSlider.value = savedSettings.keepSilence || defaultSettings.keepSilence;
        crossfadeSlider.value = savedSettings.crossfade || defaultSettings.crossfade;
        
        // Update displays
        updateSettingsDisplay();
    }
    
    // Save settings to localStorage
    function saveSettings() {
        const settings = {
            minSilenceLen: parseInt(minSilenceLenSlider.value),
            silenceThresh: parseInt(silenceThreshSlider.value),
            keepSilence: parseInt(keepSilenceSlider.value),
            crossfade: parseInt(crossfadeSlider.value)
        };
        
        localStorage.setItem('audioProcessorSettings', JSON.stringify(settings));
    }
    
    // Update settings displays
    function updateSettingsDisplay() {
        minSilenceValue.textContent = `${minSilenceLenSlider.value} ms`;
        silenceThreshValue.textContent = `${silenceThreshSlider.value} dB`;
        keepSilenceValue.textContent = `${keepSilenceSlider.value} ms`;
        crossfadeValue.textContent = `${crossfadeSlider.value} ms`;
    }
    
    // Reset settings to defaults
    function resetSettings() {
        minSilenceLenSlider.value = defaultSettings.minSilenceLen;
        silenceThreshSlider.value = defaultSettings.silenceThresh;
        keepSilenceSlider.value = defaultSettings.keepSilence;
        crossfadeSlider.value = defaultSettings.crossfade;
        
        updateSettingsDisplay();
        saveSettings();
    }
    
    // Initialize AudioContext
    function initAudioContext() {
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
    }
    
    // Load audio file
    function loadAudioFile(file) {
        initAudioContext();
        
        // Clear previous audio
        clearAudio();
        
        // Update file info
        fileName.textContent = file.name;
        fileSize.textContent = formatFileSize(file.size);
        fileDuration.textContent = "Loading...";
        fileInfoDiv.style.display = "block";
        
        const reader = new FileReader();
        
        reader.onload = function(e) {
            const arrayBuffer = e.target.result;
            
            audioContext.decodeAudioData(arrayBuffer)
                .then(function(buffer) {
                    originalAudioBuffer = buffer;
                    
                    // Update duration display
                    fileDuration.textContent = formatTime(buffer.duration);
                    
                    // Create audio element
                    const url = URL.createObjectURL(file);
                    inputAudio.src = url;
                    inputAudioContainer.style.display = "block";
                    
                    // Enable process button
                    processBtn.disabled = false;
                })
                .catch(function(error) {
                    console.error("Error decoding audio data", error);
                    alert("Error loading audio file. Make sure it's a valid WAV file.");
                });
        };
        
        reader.readAsArrayBuffer(file);
    }
    
    // Clear audio data
    function clearAudio() {
        // Reset UI elements
        stats.style.display = "none";
        outputAudioContainer.style.display = "none";
        downloadSection.style.display = "none";
        
        // Clear audio data
        if (inputAudio.src) {
            URL.revokeObjectURL(inputAudio.src);
            inputAudio.src = "";
        }
        
        if (outputAudio.src) {
            URL.revokeObjectURL(outputAudio.src);
            outputAudio.src = "";
        }
        
        if (processedBlob) {
            URL.revokeObjectURL(processedBlob);
            processedBlob = null;
        }
        
        originalAudioBuffer = null;
        processedAudioBuffer = null;
    }
    
    // Process audio to remove silence
    function processAudio() {
        if (!originalAudioBuffer) return;
        
        // Show progress
        progressContainer.style.display = "block";
        progressFill.style.width = "0%";
        statusText.textContent = "Processing...";
        
        // Get settings
        const minSilenceLen = parseInt(minSilenceLenSlider.value);
        const silenceThresh = parseInt(silenceThreshSlider.value);
        const keepSilence = parseInt(keepSilenceSlider.value);
        const crossfade = parseInt(crossfadeSlider.value);
        
        // Convert to samples
        const sampleRate = originalAudioBuffer.sampleRate;
        const minSilenceSamples = Math.floor(minSilenceLen * sampleRate / 1000);
        const keepSilenceSamples = Math.floor(keepSilence * sampleRate / 1000);
        const crossfadeSamples = Math.floor(crossfade * sampleRate / 1000);
        
        // Process in a worker to avoid UI freezing
        setTimeout(() => {
            try {
                // Convert buffer to array
                const audioData = originalAudioBuffer.getChannelData(0);
                
                // Convert threshold from dB to amplitude
                const thresholdAmplitude = Math.pow(10, silenceThresh / 20);
                
                // Find non-silent chunks
                const nonSilentChunks = detectNonSilent(audioData, thresholdAmplitude, minSilenceSamples);
                
                if (nonSilentChunks.length === 0) {
                    statusText.textContent = "No non-silent segments detected. Try adjusting the threshold.";
                    progressFill.style.width = "100%";
                    return;
                }
                
                // Update progress
                progressFill.style.width = "50%";
                statusText.textContent = "Creating new audio...";
                
                // Create new audio with reduced silence
                const result = createReducedSilenceAudio(
                    originalAudioBuffer, 
                    nonSilentChunks, 
                    keepSilenceSamples, 
                    crossfadeSamples
                );
                
                processedAudioBuffer = result.buffer;
                
                // Create WAV file
                const wav = audioBufferToWav(processedAudioBuffer);
                processedBlob = new Blob([wav], { type: 'audio/wav' });
                const url = URL.createObjectURL(processedBlob);
                
                // Update UI
                outputAudio.src = url;
                outputAudioContainer.style.display = "block";
                downloadSection.style.display = "block";
                
                // Update stats
                const origDur = originalAudioBuffer.duration;
                const newDur = processedAudioBuffer.duration;
                const saved = origDur - newDur;
                const percentage = (saved / origDur) * 100;
                
                originalDuration.textContent = `${origDur.toFixed(2)} sec`;
                newDuration.textContent = `${newDur.toFixed(2)} sec`;
                timeSaved.textContent = `${saved.toFixed(2)} sec (${percentage.toFixed(1)}%)`;
                stats.style.display = "block";
                
                // Complete progress
                progressFill.style.width = "100%";
                statusText.textContent = "Processing complete!";
                
                // Hide progress after delay
                setTimeout(() => {
                    progressContainer.style.display = "none";
                }, 2000);
            } catch (error) {
                console.error("Processing error:", error);
                statusText.textContent = "Error processing audio. " + error.message;
                progressFill.style.width = "100%";
            }
        }, 100);
    }
    
    // Detect non-silent segments
    function detectNonSilent(audioData, threshold, minSilenceSamples) {
        const chunks = [];
        let inSilence = true;
        let silenceStart = 0;
        let silenceEnd = 0;
        
        // Go through audio data
        for (let i = 0; i < audioData.length; i++) {
            const amplitude = Math.abs(audioData[i]);
            
            if (amplitude > threshold) {
                // Found a non-silent sample
                if (inSilence) {
                    inSilence = false;
                    
                    // If previous silence was long enough, end silence
                    if (i - silenceStart >= minSilenceSamples) {
                        silenceEnd = i;
                    } else {
                        // Otherwise, this is part of the previous non-silent chunk
                        if (chunks.length > 0) {
                            chunks[chunks.length - 1][1] = i;
                        } else {
                            // First chunk
                            chunks.push([0, i]);
                        }
                    }
                    
                    // Add new non-silent chunk
                    chunks.push([i, i]);
                }
                
                // Extend current non-silent chunk
                if (chunks.length > 0) {
                    chunks[chunks.length - 1][1] = i;
                }
            } else {
                // Found a silent sample
                if (!inSilence) {
                    inSilence = true;
                    silenceStart = i;
                }
            }
        }
        
        return chunks;
    }
    
    // Create audio with reduced silence
    function createReducedSilenceAudio(originalBuffer, nonSilentChunks, keepSilenceSamples, crossfadeSamples) {
        const numChannels = originalBuffer.numberOfChannels;
        const sampleRate = originalBuffer.sampleRate;
        
        // Calculate total length of the new buffer
        let totalLength = 0;
        for (let i = 0; i < nonSilentChunks.length; i++) {
            const [start, end] = nonSilentChunks[i];
            const chunkStart = Math.max(0, start - keepSilenceSamples);
            const chunkEnd = Math.min(originalBuffer.length, end + keepSilenceSamples);
            totalLength += (chunkEnd - chunkStart);
        }
        
        // Add crossfade samples for each join
        totalLength += (nonSilentChunks.length - 1) * crossfadeSamples;
        
        // Create new buffer
        const newBuffer = audioContext.createBuffer(
            numChannels,
            totalLength,
            sampleRate
        );
        
        // Fill new buffer with chunks
        let newBufferPos = 0;
        
        for (let c = 0; c < numChannels; c++) {
            const channelData = originalBuffer.getChannelData(c);
            const newChannelData = newBuffer.getChannelData(c);
            
            for (let i = 0; i < nonSilentChunks.length; i++) {
                const [start, end] = nonSilentChunks[i];
                const chunkStart = Math.max(0, start - keepSilenceSamples);
                const chunkEnd = Math.min(originalBuffer.length, end + keepSilenceSamples);
                
                // Copy chunk
                for (let j = chunkStart; j < chunkEnd; j++) {
                    newChannelData[newBufferPos + (j - chunkStart)] = channelData[j];
                }
                
                // Apply crossfade if not the last chunk
                if (i < nonSilentChunks.length - 1 && crossfadeSamples > 0) {
                    const nextChunk = nonSilentChunks[i + 1];
                    const nextStart = Math.max(0, nextChunk[0] - keepSilenceSamples);
                    
                    // Apply crossfade between chunks
                    for (let f = 0; f < crossfadeSamples; f++) {
                        const fadeOutPos = newBufferPos + (chunkEnd - chunkStart) - crossfadeSamples + f;
                        const fadeInPos = nextStart + f;
                        
                        if (fadeOutPos >= 0 && fadeOutPos < newChannelData.length && 
                            fadeInPos >= 0 && fadeInPos < channelData.length) {
                            
                            // Linear crossfade
                            const fadeOutWeight = 1 - (f / crossfadeSamples);
                            const fadeInWeight = f / crossfadeSamples;
                            
                            newChannelData[fadeOutPos] = 
                                (newChannelData[fadeOutPos] * fadeOutWeight) + 
                                (channelData[fadeInPos] * fadeInWeight);
                        }
                    }
                }
                
                newBufferPos += (chunkEnd - chunkStart);
            }
        }
        
        return {
            buffer: newBuffer,
            duration: newBuffer.duration
        };
    }
    
    // Format file size to human readable
    function formatFileSize(bytes) {
        if (bytes < 1024) {
            return bytes + " bytes";
        } else if (bytes < 1024 * 1024) {
            return (bytes / 1024).toFixed(2) + " KB";
        } else {
            return (bytes / (1024 * 1024)).toFixed(2) + " MB";
        }
    }
    
    // Format time in seconds to MM:SS format
    function formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${minutes}:${secs.toString().padStart(2, '0')} (${seconds.toFixed(2)} sec)`;
    }
    
    // Convert AudioBuffer to WAV
    function audioBufferToWav(buffer) {
        const numChannels = buffer.numberOfChannels;
        const sampleRate = buffer.sampleRate;
        const format = 1; // PCM
        const bitDepth = 16;
        
        let result;
        
        if (numChannels === 2) {
            result = interleave(buffer.getChannelData(0), buffer.getChannelData(1));
        } else {
            result = buffer.getChannelData(0);
        }
        
        return encodeWAV(result, format, sampleRate, numChannels, bitDepth);
    }
    
    // Interleave two channels
    function interleave(inputL, inputR) {
        const length = inputL.length + inputR.length;
        const result = new Float32Array(length);
        
        let index = 0;
        let inputIndex = 0;
        
        while (index < length) {
            result[index++] = inputL[inputIndex];
            result[index++] = inputR[inputIndex];
            inputIndex++;
        }
        
        return result;
    }
    
    // Encode WAV file
    function encodeWAV(samples, format, sampleRate, numChannels, bitDepth) {
        const bytesPerSample = bitDepth / 8;
        const blockAlign = numChannels * bytesPerSample;
        
        const buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);
        const view = new DataView(buffer);
        
        // RIFF identifier
        writeString(view, 0, 'RIFF');
        // RIFF chunk length
        view.setUint32(4, 36 + samples.length * bytesPerSample, true);
        // RIFF type
        writeString(view, 8, 'WAVE');
        // format chunk identifier
        writeString(view, 12, 'fmt ');
        // format chunk length
        view.setUint32(16, 16, true);
        // sample format (raw)
        view.setUint16(20, format, true);
        // channel count
        view.setUint16(22, numChannels, true);
        // sample rate
        view.setUint32(24, sampleRate, true);
        // byte rate (sample rate * block align)
        view.setUint32(28, sampleRate * blockAlign, true);
        // block align (channel count * bytes per sample)
        view.setUint16(32, blockAlign, true);
        // bits per sample
        view.setUint16(34, bitDepth, true);
        // data chunk identifier
        writeString(view, 36, 'data');
        // data chunk length
        view.setUint32(40, samples.length * bytesPerSample, true);
        
        // Write the PCM samples
        const offset = 44;
        if (bitDepth === 16) {
            floatTo16BitPCM(view, offset, samples);
        } else {
            floatTo8BitPCM(view, offset, samples);
        }
        
        return buffer;
    }
    
    // Write a string to a DataView
    function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    }
    
    // Convert Float32 to 16-bit PCM
    function floatTo16BitPCM(output, offset, input) {
        for (let i = 0; i < input.length; i++, offset += 2) {
            const s = Math.max(-1, Math.min(1, input[i]));
            output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
        }
    }
    
    // Convert Float32 to 8-bit PCM
    function floatTo8BitPCM(output, offset, input) {
        for (let i = 0; i < input.length; i++, offset++) {
            const s = Math.max(-1, Math.min(1, input[i]));
            const val = s < 0 ? s * 0x80 : s * 0x7F;
            output.setInt8(offset, val + 128);
        }
    }
    
    // Event listeners
    audioFileInput.addEventListener('change', function(e) {
        if (this.files && this.files[0]) {
            loadAudioFile(this.files[0]);
        }
    });
    
    processBtn.addEventListener('click', processAudio);
    
    resetSettingsBtn.addEventListener('click', resetSettings);
    
    downloadBtn.addEventListener('click', function() {
        if (processedBlob) {
            const url = URL.createObjectURL(processedBlob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = 'smooth_voice.wav';
            document.body.appendChild(a);
            a.click();
            window.setTimeout(() => {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }, 100);
        }
    });
    
    // Slider events
    minSilenceLenSlider.addEventListener('input', function() {
        minSilenceValue.textContent = `${this.value} ms`;
    });
    
    silenceThreshSlider.addEventListener('input', function() {
        silenceThreshValue.textContent = `${this.value} dB`;
    });
    
    keepSilenceSlider.addEventListener('input', function() {
        keepSilenceValue.textContent = `${this.value} ms`;
    });
    
    crossfadeSlider.addEventListener('input', function() {
        crossfadeValue.textContent = `${this.value} ms`;
    });
    
    // Save settings on slider change
    minSilenceLenSlider.addEventListener('change', saveSettings);
    silenceThreshSlider.addEventListener('change', saveSettings);
    keepSilenceSlider.addEventListener('change', saveSettings);
    crossfadeSlider.addEventListener('change', saveSettings);
    
    // Initialize
    loadSettings();
});
      </script>
    
</body>
    </html>
